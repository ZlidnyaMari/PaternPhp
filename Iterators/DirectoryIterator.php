<?php
//*Папки и файлы test созданы для тестирования вывода в консоли.
$dir = new DirectoryIterator("../Iterators");

    foreach ($dir as $item) {
        if($item != '..' && $item != '.') {
            echo $item->current() . "\n";
    }    
}

$it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator("../Iterators"));

    foreach ($it as $file) {
        if($file != '..' && $file != '.') {
            echo 'SubPathName: ' . $it->getSubPathName() . "\n";
            echo 'SubPath:     ' . $it->getSubPath() . "\n\n";
    }
} 

/*

По поводу задания определения сложности рекурсии. Вот нашла на просторах интернета:

Напомним, что рекурсивными процедурами называются процедуры, 
которые вызывают сами себя. Их сложность определить довольно тяжело. 
Сложность этих алгоритмов зависит не только от сложности внутренних циклов, но и от количества 
итераций рекурсии. Рекурсивная процедура может выглядеть достаточно простой, но она может серьёзно 
усложнить программу, многократно вызывая себя.
Рассмотрим рекурсивную реализацию вычисления факториала:
function Factorial(n: Word): integer;
begin
if n > 1 then
Factorial:=n*Factorial(n-1)
else
Factorial:=1;
end;
Эта процедура выполняется N раз, таким образом, вычислительная сложность этого алгоритма равна O(N).

Задание 3.1
Полное число исполнений вложенного цикла, всегда равно произведению числа итераций внутреннего цикла 
на произведение чисел итераций всех внешних циклов
В данном примере создается 100 (от 0 до 99) массивов, в каждом по 7 элементов. Итого 700 итерации. 
Вычисляеься путем добавление счетчика ++$count;
Вложенный цикл имеет квадратичную сложность O(N * N) = O(N2).

Задание 3.2
Число итераций 2550. 
Считаю что сложность О(NlogN) поскольку переменная итерирования умножается на положительну константу.
*/